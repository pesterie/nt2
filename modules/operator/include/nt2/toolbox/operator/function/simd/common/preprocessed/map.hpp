namespace nt2 { namespace meta { template<class Func , class A0 , class X> nt2::ext:: call< tag::map_(typename nt2::meta::unspecified_<Func>::type , typename nt2::meta::simd_< unspecified_<A0>, X >::type) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<Func> const& , nt2::meta::simd_< unspecified_<A0>, X > const& , adl_helper = adl_helper() ); } } namespace nt2 { namespace ext { template<class X, class Dummy> struct call<tag::map_( tag::unspecified_ , tag::simd_<tag::unspecified_, X> ) , tag::cpu_, Dummy > : callable { template<class Sig> struct result; template<class This,class Func,class A0> struct result<This(Func, A0)> { typedef typename meta:: result_of< typename meta:: strip<Func>::type const( typename meta::scalar_of<A0>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, X> type; }; template<class Func, class A0> typename result<call(Func, A0)>::type operator()(Func const& f, A0 const& a0) { typedef typename result<call(Func, A0)>::type ntype; typedef typename result<call(Func, A0)>::stype stype; stype NT2_ALIGN_ON(16) tmp[meta::cardinal_of<A0>::value]; for(int i = 0; i != meta::cardinal_of<A0>::value; ++i) tmp[i] = details::maybe_genmask<stype>(f(a0[i])); return load<ntype>(&tmp[0], 0); } }; } } namespace nt2 { namespace meta { template<class Func , class A0 , class X> nt2::ext:: call< tag::map_(typename nt2::meta::unspecified_<Func>::type , typename nt2::meta::simd_< unspecified_<A0>, X >::type , typename nt2::meta::simd_< unspecified_<A0>, X >::type) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<Func> const& , nt2::meta::simd_< unspecified_<A0>, X > const& , nt2::meta::simd_< unspecified_<A0>, X > const& , adl_helper = adl_helper() ); } } namespace nt2 { namespace ext { template<class X, class Dummy> struct call<tag::map_( tag::unspecified_ , tag::simd_<tag::unspecified_, X> , tag::simd_<tag::unspecified_, X> ) , tag::cpu_, Dummy > : callable { template<class Sig> struct result; template<class This,class Func,class A0 , class A1> struct result<This(Func, A0 , A1)> { typedef typename meta:: result_of< typename meta:: strip<Func>::type const( typename meta::scalar_of<A0>::type , typename meta::scalar_of<A1>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, X> type; }; template<class Func, class A0 , class A1> typename result<call(Func, A0 , A1)>::type operator()(Func const& f, A0 const& a0 , A1 const& a1) { typedef typename result<call(Func, A0 , A1)>::type ntype; typedef typename result<call(Func, A0 , A1)>::stype stype; stype NT2_ALIGN_ON(16) tmp[meta::cardinal_of<A0>::value]; for(int i = 0; i != meta::cardinal_of<A0>::value; ++i) tmp[i] = details::maybe_genmask<stype>(f(a0[i] , a1[i])); return load<ntype>(&tmp[0], 0); } }; } } namespace nt2 { namespace meta { template<class Func , class A0 , class X> nt2::ext:: call< tag::map_(typename nt2::meta::unspecified_<Func>::type , typename nt2::meta::simd_< unspecified_<A0>, X >::type , typename nt2::meta::simd_< unspecified_<A0>, X >::type , typename nt2::meta::simd_< unspecified_<A0>, X >::type) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<Func> const& , nt2::meta::simd_< unspecified_<A0>, X > const& , nt2::meta::simd_< unspecified_<A0>, X > const& , nt2::meta::simd_< unspecified_<A0>, X > const& , adl_helper = adl_helper() ); } } namespace nt2 { namespace ext { template<class X, class Dummy> struct call<tag::map_( tag::unspecified_ , tag::simd_<tag::unspecified_, X> , tag::simd_<tag::unspecified_, X> , tag::simd_<tag::unspecified_, X> ) , tag::cpu_, Dummy > : callable { template<class Sig> struct result; template<class This,class Func,class A0 , class A1 , class A2> struct result<This(Func, A0 , A1 , A2)> { typedef typename meta:: result_of< typename meta:: strip<Func>::type const( typename meta::scalar_of<A0>::type , typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, X> type; }; template<class Func, class A0 , class A1 , class A2> typename result<call(Func, A0 , A1 , A2)>::type operator()(Func const& f, A0 const& a0 , A1 const& a1 , A2 const& a2) { typedef typename result<call(Func, A0 , A1 , A2)>::type ntype; typedef typename result<call(Func, A0 , A1 , A2)>::stype stype; stype NT2_ALIGN_ON(16) tmp[meta::cardinal_of<A0>::value]; for(int i = 0; i != meta::cardinal_of<A0>::value; ++i) tmp[i] = details::maybe_genmask<stype>(f(a0[i] , a1[i] , a2[i])); return load<ntype>(&tmp[0], 0); } }; } } namespace nt2 { namespace meta { template<class Func , class A0 , class X> nt2::ext:: call< tag::map_(typename nt2::meta::unspecified_<Func>::type , typename nt2::meta::simd_< unspecified_<A0>, X >::type , typename nt2::meta::simd_< unspecified_<A0>, X >::type , typename nt2::meta::simd_< unspecified_<A0>, X >::type , typename nt2::meta::simd_< unspecified_<A0>, X >::type) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<Func> const& , nt2::meta::simd_< unspecified_<A0>, X > const& , nt2::meta::simd_< unspecified_<A0>, X > const& , nt2::meta::simd_< unspecified_<A0>, X > const& , nt2::meta::simd_< unspecified_<A0>, X > const& , adl_helper = adl_helper() ); } } namespace nt2 { namespace ext { template<class X, class Dummy> struct call<tag::map_( tag::unspecified_ , tag::simd_<tag::unspecified_, X> , tag::simd_<tag::unspecified_, X> , tag::simd_<tag::unspecified_, X> , tag::simd_<tag::unspecified_, X> ) , tag::cpu_, Dummy > : callable { template<class Sig> struct result; template<class This,class Func,class A0 , class A1 , class A2 , class A3> struct result<This(Func, A0 , A1 , A2 , A3)> { typedef typename meta:: result_of< typename meta:: strip<Func>::type const( typename meta::scalar_of<A0>::type , typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type , typename meta::scalar_of<A3>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, X> type; }; template<class Func, class A0 , class A1 , class A2 , class A3> typename result<call(Func, A0 , A1 , A2 , A3)>::type operator()(Func const& f, A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3) { typedef typename result<call(Func, A0 , A1 , A2 , A3)>::type ntype; typedef typename result<call(Func, A0 , A1 , A2 , A3)>::stype stype; stype NT2_ALIGN_ON(16) tmp[meta::cardinal_of<A0>::value]; for(int i = 0; i != meta::cardinal_of<A0>::value; ++i) tmp[i] = details::maybe_genmask<stype>(f(a0[i] , a1[i] , a2[i] , a3[i])); return load<ntype>(&tmp[0], 0); } }; } } namespace nt2 { namespace meta { template<class Func , class A0 , class X> nt2::ext:: call< tag::map_(typename nt2::meta::unspecified_<Func>::type , typename nt2::meta::simd_< unspecified_<A0>, X >::type , typename nt2::meta::simd_< unspecified_<A0>, X >::type , typename nt2::meta::simd_< unspecified_<A0>, X >::type , typename nt2::meta::simd_< unspecified_<A0>, X >::type , typename nt2::meta::simd_< unspecified_<A0>, X >::type) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<Func> const& , nt2::meta::simd_< unspecified_<A0>, X > const& , nt2::meta::simd_< unspecified_<A0>, X > const& , nt2::meta::simd_< unspecified_<A0>, X > const& , nt2::meta::simd_< unspecified_<A0>, X > const& , nt2::meta::simd_< unspecified_<A0>, X > const& , adl_helper = adl_helper() ); } } namespace nt2 { namespace ext { template<class X, class Dummy> struct call<tag::map_( tag::unspecified_ , tag::simd_<tag::unspecified_, X> , tag::simd_<tag::unspecified_, X> , tag::simd_<tag::unspecified_, X> , tag::simd_<tag::unspecified_, X> , tag::simd_<tag::unspecified_, X> ) , tag::cpu_, Dummy > : callable { template<class Sig> struct result; template<class This,class Func,class A0 , class A1 , class A2 , class A3 , class A4> struct result<This(Func, A0 , A1 , A2 , A3 , A4)> { typedef typename meta:: result_of< typename meta:: strip<Func>::type const( typename meta::scalar_of<A0>::type , typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type , typename meta::scalar_of<A3>::type , typename meta::scalar_of<A4>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, X> type; }; template<class Func, class A0 , class A1 , class A2 , class A3 , class A4> typename result<call(Func, A0 , A1 , A2 , A3 , A4)>::type operator()(Func const& f, A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4) { typedef typename result<call(Func, A0 , A1 , A2 , A3 , A4)>::type ntype; typedef typename result<call(Func, A0 , A1 , A2 , A3 , A4)>::stype stype; stype NT2_ALIGN_ON(16) tmp[meta::cardinal_of<A0>::value]; for(int i = 0; i != meta::cardinal_of<A0>::value; ++i) tmp[i] = details::maybe_genmask<stype>(f(a0[i] , a1[i] , a2[i] , a3[i] , a4[i])); return load<ntype>(&tmp[0], 0); } }; } }
