namespace nt2 { namespace meta { template<class Func , class A0> nt2::ext:: call< tag::map_(typename nt2::meta::unspecified_<Func>::type , typename nt2::meta::simd_<ints64_<A0>,tag::sse_>::type) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<Func> const& , nt2::meta::simd_<ints64_<A0>,tag::sse_> const& , adl_helper = adl_helper() ); } } namespace nt2 { namespace ext { template<class Dummy> struct call < tag::map_ ( tag::unspecified_ , tag::simd_< tag::ints64_ , tag::sse_ > ) , tag::cpu_ , Dummy> : callable { template<class Sig> struct result; template<class This,class Func,class A0> struct result<This(Func, A0)> { typedef typename meta:: result_of< typename meta:: strip<Func>::type const( typename meta::scalar_of<A0>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> type; }; template<class A0 , class A1> inline typename meta::result_of<call(A0 const& , A1 const&)>::type operator()( A0 const& a0 , A1 const& a1 ) const { typedef typename result<call(A0 , A1)>::type ntype; typedef typename result<call(A0 , A1)>::stype stype; return make<ntype>(details::maybe_genmask<stype>(a0(a1[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1]))); } }; } } namespace nt2 { namespace meta { template<class Func , class A0 , class A1> nt2::ext:: call< tag::map_(typename nt2::meta::unspecified_<Func>::type , typename nt2::meta::simd_<ints64_<A0>,tag::sse_>::type , typename nt2::meta::simd_< arithmetic_<A1>,tag::sse_>::type) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<Func> const& , nt2::meta::simd_<ints64_<A0>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A1>,tag::sse_> const& , adl_helper = adl_helper() ); } } namespace nt2 { namespace ext { template<class Dummy> struct call < tag::map_ ( tag::unspecified_ , tag::simd_< tag::ints64_ , tag::sse_ > ,tag::simd_<tag::arithmetic_,tag::sse_> ) , tag::cpu_ , Dummy> : callable { template<class Sig> struct result; template<class This,class Func,class A0 , class A1> struct result<This(Func, A0 , A1)> { typedef typename meta:: result_of< typename meta:: strip<Func>::type const( typename meta::scalar_of<A0>::type , typename meta::scalar_of<A1>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> type; }; template<class A0 , class A1 , class A2> inline typename meta::result_of<call(A0 const& , A1 const& , A2 const&)>::type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 ) const { typedef typename result<call(A0 , A1 , A2)>::type ntype; typedef typename result<call(A0 , A1 , A2)>::stype stype; return make<ntype>(details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1]))); } }; } } namespace nt2 { namespace meta { template<class Func , class A0 , class A1 , class A2> nt2::ext:: call< tag::map_(typename nt2::meta::unspecified_<Func>::type , typename nt2::meta::simd_<ints64_<A0>,tag::sse_>::type , typename nt2::meta::simd_< arithmetic_<A1>,tag::sse_>::type , typename nt2::meta::simd_< arithmetic_<A2>,tag::sse_>::type) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<Func> const& , nt2::meta::simd_<ints64_<A0>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A1>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> const& , adl_helper = adl_helper() ); } } namespace nt2 { namespace ext { template<class Dummy> struct call < tag::map_ ( tag::unspecified_ , tag::simd_< tag::ints64_ , tag::sse_ > ,tag::simd_<tag::arithmetic_,tag::sse_> ,tag::simd_<tag::arithmetic_,tag::sse_> ) , tag::cpu_ , Dummy> : callable { template<class Sig> struct result; template<class This,class Func,class A0 , class A1 , class A2> struct result<This(Func, A0 , A1 , A2)> { typedef typename meta:: result_of< typename meta:: strip<Func>::type const( typename meta::scalar_of<A0>::type , typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> type; }; template<class A0 , class A1 , class A2 , class A3> inline typename meta::result_of<call(A0 const& , A1 const& , A2 const& , A3 const&)>::type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 ) const { typedef typename result<call(A0 , A1 , A2 , A3)>::type ntype; typedef typename result<call(A0 , A1 , A2 , A3)>::stype stype; return make<ntype>(details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0] , a3[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1] , a3[ 1]))); } }; } } namespace nt2 { namespace meta { template<class Func , class A0 , class A1 , class A2 , class A3> nt2::ext:: call< tag::map_(typename nt2::meta::unspecified_<Func>::type , typename nt2::meta::simd_<ints64_<A0>,tag::sse_>::type , typename nt2::meta::simd_< arithmetic_<A1>,tag::sse_>::type , typename nt2::meta::simd_< arithmetic_<A2>,tag::sse_>::type , typename nt2::meta::simd_< arithmetic_<A3>,tag::sse_>::type) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<Func> const& , nt2::meta::simd_<ints64_<A0>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A1>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> const& , adl_helper = adl_helper() ); } } namespace nt2 { namespace ext { template<class Dummy> struct call < tag::map_ ( tag::unspecified_ , tag::simd_< tag::ints64_ , tag::sse_ > ,tag::simd_<tag::arithmetic_,tag::sse_> ,tag::simd_<tag::arithmetic_,tag::sse_> ,tag::simd_<tag::arithmetic_,tag::sse_> ) , tag::cpu_ , Dummy> : callable { template<class Sig> struct result; template<class This,class Func,class A0 , class A1 , class A2 , class A3> struct result<This(Func, A0 , A1 , A2 , A3)> { typedef typename meta:: result_of< typename meta:: strip<Func>::type const( typename meta::scalar_of<A0>::type , typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type , typename meta::scalar_of<A3>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> type; }; template<class A0 , class A1 , class A2 , class A3 , class A4> inline typename meta::result_of<call(A0 const& , A1 const& , A2 const& , A3 const& , A4 const&)>::type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 ) const { typedef typename result<call(A0 , A1 , A2 , A3 , A4)>::type ntype; typedef typename result<call(A0 , A1 , A2 , A3 , A4)>::stype stype; return make<ntype>(details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0] , a3[ 0] , a4[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1] , a3[ 1] , a4[ 1]))); } }; } }
namespace nt2 { namespace meta { template<class Func , class A0> nt2::ext:: call< tag::map_(typename nt2::meta::unspecified_<Func>::type , typename nt2::meta::simd_<double_<A0>,tag::sse_>::type) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<Func> const& , nt2::meta::simd_<double_<A0>,tag::sse_> const& , adl_helper = adl_helper() ); } } namespace nt2 { namespace ext { template<class Dummy> struct call < tag::map_ ( tag::unspecified_ , tag::simd_< tag::double_ , tag::sse_ > ) , tag::cpu_ , Dummy> : callable { template<class Sig> struct result; template<class This,class Func,class A0> struct result<This(Func, A0)> { typedef typename meta:: result_of< typename meta:: strip<Func>::type const( typename meta::scalar_of<A0>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> type; }; template<class A0 , class A1> inline typename meta::result_of<call(A0 const& , A1 const&)>::type operator()( A0 const& a0 , A1 const& a1 ) const { typedef typename result<call(A0 , A1)>::type ntype; typedef typename result<call(A0 , A1)>::stype stype; return make<ntype>(details::maybe_genmask<stype>(a0(a1[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1]))); } }; } } namespace nt2 { namespace meta { template<class Func , class A0 , class A1> nt2::ext:: call< tag::map_(typename nt2::meta::unspecified_<Func>::type , typename nt2::meta::simd_<double_<A0>,tag::sse_>::type , typename nt2::meta::simd_< arithmetic_<A1>,tag::sse_>::type) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<Func> const& , nt2::meta::simd_<double_<A0>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A1>,tag::sse_> const& , adl_helper = adl_helper() ); } } namespace nt2 { namespace ext { template<class Dummy> struct call < tag::map_ ( tag::unspecified_ , tag::simd_< tag::double_ , tag::sse_ > ,tag::simd_<tag::arithmetic_,tag::sse_> ) , tag::cpu_ , Dummy> : callable { template<class Sig> struct result; template<class This,class Func,class A0 , class A1> struct result<This(Func, A0 , A1)> { typedef typename meta:: result_of< typename meta:: strip<Func>::type const( typename meta::scalar_of<A0>::type , typename meta::scalar_of<A1>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> type; }; template<class A0 , class A1 , class A2> inline typename meta::result_of<call(A0 const& , A1 const& , A2 const&)>::type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 ) const { typedef typename result<call(A0 , A1 , A2)>::type ntype; typedef typename result<call(A0 , A1 , A2)>::stype stype; return make<ntype>(details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1]))); } }; } } namespace nt2 { namespace meta { template<class Func , class A0 , class A1 , class A2> nt2::ext:: call< tag::map_(typename nt2::meta::unspecified_<Func>::type , typename nt2::meta::simd_<double_<A0>,tag::sse_>::type , typename nt2::meta::simd_< arithmetic_<A1>,tag::sse_>::type , typename nt2::meta::simd_< arithmetic_<A2>,tag::sse_>::type) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<Func> const& , nt2::meta::simd_<double_<A0>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A1>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> const& , adl_helper = adl_helper() ); } } namespace nt2 { namespace ext { template<class Dummy> struct call < tag::map_ ( tag::unspecified_ , tag::simd_< tag::double_ , tag::sse_ > ,tag::simd_<tag::arithmetic_,tag::sse_> ,tag::simd_<tag::arithmetic_,tag::sse_> ) , tag::cpu_ , Dummy> : callable { template<class Sig> struct result; template<class This,class Func,class A0 , class A1 , class A2> struct result<This(Func, A0 , A1 , A2)> { typedef typename meta:: result_of< typename meta:: strip<Func>::type const( typename meta::scalar_of<A0>::type , typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> type; }; template<class A0 , class A1 , class A2 , class A3> inline typename meta::result_of<call(A0 const& , A1 const& , A2 const& , A3 const&)>::type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 ) const { typedef typename result<call(A0 , A1 , A2 , A3)>::type ntype; typedef typename result<call(A0 , A1 , A2 , A3)>::stype stype; return make<ntype>(details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0] , a3[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1] , a3[ 1]))); } }; } } namespace nt2 { namespace meta { template<class Func , class A0 , class A1 , class A2 , class A3> nt2::ext:: call< tag::map_(typename nt2::meta::unspecified_<Func>::type , typename nt2::meta::simd_<double_<A0>,tag::sse_>::type , typename nt2::meta::simd_< arithmetic_<A1>,tag::sse_>::type , typename nt2::meta::simd_< arithmetic_<A2>,tag::sse_>::type , typename nt2::meta::simd_< arithmetic_<A3>,tag::sse_>::type) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<Func> const& , nt2::meta::simd_<double_<A0>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A1>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> const& , adl_helper = adl_helper() ); } } namespace nt2 { namespace ext { template<class Dummy> struct call < tag::map_ ( tag::unspecified_ , tag::simd_< tag::double_ , tag::sse_ > ,tag::simd_<tag::arithmetic_,tag::sse_> ,tag::simd_<tag::arithmetic_,tag::sse_> ,tag::simd_<tag::arithmetic_,tag::sse_> ) , tag::cpu_ , Dummy> : callable { template<class Sig> struct result; template<class This,class Func,class A0 , class A1 , class A2 , class A3> struct result<This(Func, A0 , A1 , A2 , A3)> { typedef typename meta:: result_of< typename meta:: strip<Func>::type const( typename meta::scalar_of<A0>::type , typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type , typename meta::scalar_of<A3>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> type; }; template<class A0 , class A1 , class A2 , class A3 , class A4> inline typename meta::result_of<call(A0 const& , A1 const& , A2 const& , A3 const& , A4 const&)>::type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 ) const { typedef typename result<call(A0 , A1 , A2 , A3 , A4)>::type ntype; typedef typename result<call(A0 , A1 , A2 , A3 , A4)>::stype stype; return make<ntype>(details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0] , a3[ 0] , a4[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1] , a3[ 1] , a4[ 1]))); } }; } }
namespace nt2 { namespace meta { template<class Func , class A0> nt2::ext:: call< tag::map_(typename nt2::meta::unspecified_<Func>::type , typename nt2::meta::simd_<float_<A0>,tag::sse_>::type) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<Func> const& , nt2::meta::simd_<float_<A0>,tag::sse_> const& , adl_helper = adl_helper() ); } } namespace nt2 { namespace ext { template<class Dummy> struct call < tag::map_ ( tag::unspecified_ , tag::simd_< tag::float_ , tag::sse_ > ) , tag::cpu_ , Dummy> : callable { template<class Sig> struct result; template<class This,class Func,class A0> struct result<This(Func, A0)> { typedef typename meta:: result_of< typename meta:: strip<Func>::type const( typename meta::scalar_of<A0>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> type; }; template<class A0 , class A1> inline typename meta::result_of<call(A0 const& , A1 const&)>::type operator()( A0 const& a0 , A1 const& a1 ) const { typedef typename result<call(A0 , A1)>::type ntype; typedef typename result<call(A0 , A1)>::stype stype; return make<ntype>(details::maybe_genmask<stype>(a0(a1[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1])) , details::maybe_genmask<stype>(a0(a1[ 2])) , details::maybe_genmask<stype>(a0(a1[ 3]))); } }; } } namespace nt2 { namespace meta { template<class Func , class A0 , class A1> nt2::ext:: call< tag::map_(typename nt2::meta::unspecified_<Func>::type , typename nt2::meta::simd_<float_<A0>,tag::sse_>::type , typename nt2::meta::simd_< arithmetic_<A1>,tag::sse_>::type) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<Func> const& , nt2::meta::simd_<float_<A0>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A1>,tag::sse_> const& , adl_helper = adl_helper() ); } } namespace nt2 { namespace ext { template<class Dummy> struct call < tag::map_ ( tag::unspecified_ , tag::simd_< tag::float_ , tag::sse_ > ,tag::simd_<tag::arithmetic_,tag::sse_> ) , tag::cpu_ , Dummy> : callable { template<class Sig> struct result; template<class This,class Func,class A0 , class A1> struct result<This(Func, A0 , A1)> { typedef typename meta:: result_of< typename meta:: strip<Func>::type const( typename meta::scalar_of<A0>::type , typename meta::scalar_of<A1>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> type; }; template<class A0 , class A1 , class A2> inline typename meta::result_of<call(A0 const& , A1 const& , A2 const&)>::type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 ) const { typedef typename result<call(A0 , A1 , A2)>::type ntype; typedef typename result<call(A0 , A1 , A2)>::stype stype; return make<ntype>(details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1])) , details::maybe_genmask<stype>(a0(a1[ 2] , a2[ 2])) , details::maybe_genmask<stype>(a0(a1[ 3] , a2[ 3]))); } }; } } namespace nt2 { namespace meta { template<class Func , class A0 , class A1 , class A2> nt2::ext:: call< tag::map_(typename nt2::meta::unspecified_<Func>::type , typename nt2::meta::simd_<float_<A0>,tag::sse_>::type , typename nt2::meta::simd_< arithmetic_<A1>,tag::sse_>::type , typename nt2::meta::simd_< arithmetic_<A2>,tag::sse_>::type) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<Func> const& , nt2::meta::simd_<float_<A0>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A1>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> const& , adl_helper = adl_helper() ); } } namespace nt2 { namespace ext { template<class Dummy> struct call < tag::map_ ( tag::unspecified_ , tag::simd_< tag::float_ , tag::sse_ > ,tag::simd_<tag::arithmetic_,tag::sse_> ,tag::simd_<tag::arithmetic_,tag::sse_> ) , tag::cpu_ , Dummy> : callable { template<class Sig> struct result; template<class This,class Func,class A0 , class A1 , class A2> struct result<This(Func, A0 , A1 , A2)> { typedef typename meta:: result_of< typename meta:: strip<Func>::type const( typename meta::scalar_of<A0>::type , typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> type; }; template<class A0 , class A1 , class A2 , class A3> inline typename meta::result_of<call(A0 const& , A1 const& , A2 const& , A3 const&)>::type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 ) const { typedef typename result<call(A0 , A1 , A2 , A3)>::type ntype; typedef typename result<call(A0 , A1 , A2 , A3)>::stype stype; return make<ntype>(details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0] , a3[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1] , a3[ 1])) , details::maybe_genmask<stype>(a0(a1[ 2] , a2[ 2] , a3[ 2])) , details::maybe_genmask<stype>(a0(a1[ 3] , a2[ 3] , a3[ 3]))); } }; } } namespace nt2 { namespace meta { template<class Func , class A0 , class A1 , class A2 , class A3> nt2::ext:: call< tag::map_(typename nt2::meta::unspecified_<Func>::type , typename nt2::meta::simd_<float_<A0>,tag::sse_>::type , typename nt2::meta::simd_< arithmetic_<A1>,tag::sse_>::type , typename nt2::meta::simd_< arithmetic_<A2>,tag::sse_>::type , typename nt2::meta::simd_< arithmetic_<A3>,tag::sse_>::type) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<Func> const& , nt2::meta::simd_<float_<A0>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A1>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> const& , adl_helper = adl_helper() ); } } namespace nt2 { namespace ext { template<class Dummy> struct call < tag::map_ ( tag::unspecified_ , tag::simd_< tag::float_ , tag::sse_ > ,tag::simd_<tag::arithmetic_,tag::sse_> ,tag::simd_<tag::arithmetic_,tag::sse_> ,tag::simd_<tag::arithmetic_,tag::sse_> ) , tag::cpu_ , Dummy> : callable { template<class Sig> struct result; template<class This,class Func,class A0 , class A1 , class A2 , class A3> struct result<This(Func, A0 , A1 , A2 , A3)> { typedef typename meta:: result_of< typename meta:: strip<Func>::type const( typename meta::scalar_of<A0>::type , typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type , typename meta::scalar_of<A3>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> type; }; template<class A0 , class A1 , class A2 , class A3 , class A4> inline typename meta::result_of<call(A0 const& , A1 const& , A2 const& , A3 const& , A4 const&)>::type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 ) const { typedef typename result<call(A0 , A1 , A2 , A3 , A4)>::type ntype; typedef typename result<call(A0 , A1 , A2 , A3 , A4)>::stype stype; return make<ntype>(details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0] , a3[ 0] , a4[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1] , a3[ 1] , a4[ 1])) , details::maybe_genmask<stype>(a0(a1[ 2] , a2[ 2] , a3[ 2] , a4[ 2])) , details::maybe_genmask<stype>(a0(a1[ 3] , a2[ 3] , a3[ 3] , a4[ 3]))); } }; } }
namespace nt2 { namespace meta { template<class Func , class A0> nt2::ext:: call< tag::map_(typename nt2::meta::unspecified_<Func>::type , typename nt2::meta::simd_<ints32_<A0>,tag::sse_>::type) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<Func> const& , nt2::meta::simd_<ints32_<A0>,tag::sse_> const& , adl_helper = adl_helper() ); } } namespace nt2 { namespace ext { template<class Dummy> struct call < tag::map_ ( tag::unspecified_ , tag::simd_< tag::ints32_ , tag::sse_ > ) , tag::cpu_ , Dummy> : callable { template<class Sig> struct result; template<class This,class Func,class A0> struct result<This(Func, A0)> { typedef typename meta:: result_of< typename meta:: strip<Func>::type const( typename meta::scalar_of<A0>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> type; }; template<class A0 , class A1> inline typename meta::result_of<call(A0 const& , A1 const&)>::type operator()( A0 const& a0 , A1 const& a1 ) const { typedef typename result<call(A0 , A1)>::type ntype; typedef typename result<call(A0 , A1)>::stype stype; return make<ntype>(details::maybe_genmask<stype>(a0(a1[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1])) , details::maybe_genmask<stype>(a0(a1[ 2])) , details::maybe_genmask<stype>(a0(a1[ 3]))); } }; } } namespace nt2 { namespace meta { template<class Func , class A0 , class A1> nt2::ext:: call< tag::map_(typename nt2::meta::unspecified_<Func>::type , typename nt2::meta::simd_<ints32_<A0>,tag::sse_>::type , typename nt2::meta::simd_< arithmetic_<A1>,tag::sse_>::type) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<Func> const& , nt2::meta::simd_<ints32_<A0>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A1>,tag::sse_> const& , adl_helper = adl_helper() ); } } namespace nt2 { namespace ext { template<class Dummy> struct call < tag::map_ ( tag::unspecified_ , tag::simd_< tag::ints32_ , tag::sse_ > ,tag::simd_<tag::arithmetic_,tag::sse_> ) , tag::cpu_ , Dummy> : callable { template<class Sig> struct result; template<class This,class Func,class A0 , class A1> struct result<This(Func, A0 , A1)> { typedef typename meta:: result_of< typename meta:: strip<Func>::type const( typename meta::scalar_of<A0>::type , typename meta::scalar_of<A1>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> type; }; template<class A0 , class A1 , class A2> inline typename meta::result_of<call(A0 const& , A1 const& , A2 const&)>::type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 ) const { typedef typename result<call(A0 , A1 , A2)>::type ntype; typedef typename result<call(A0 , A1 , A2)>::stype stype; return make<ntype>(details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1])) , details::maybe_genmask<stype>(a0(a1[ 2] , a2[ 2])) , details::maybe_genmask<stype>(a0(a1[ 3] , a2[ 3]))); } }; } } namespace nt2 { namespace meta { template<class Func , class A0 , class A1 , class A2> nt2::ext:: call< tag::map_(typename nt2::meta::unspecified_<Func>::type , typename nt2::meta::simd_<ints32_<A0>,tag::sse_>::type , typename nt2::meta::simd_< arithmetic_<A1>,tag::sse_>::type , typename nt2::meta::simd_< arithmetic_<A2>,tag::sse_>::type) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<Func> const& , nt2::meta::simd_<ints32_<A0>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A1>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> const& , adl_helper = adl_helper() ); } } namespace nt2 { namespace ext { template<class Dummy> struct call < tag::map_ ( tag::unspecified_ , tag::simd_< tag::ints32_ , tag::sse_ > ,tag::simd_<tag::arithmetic_,tag::sse_> ,tag::simd_<tag::arithmetic_,tag::sse_> ) , tag::cpu_ , Dummy> : callable { template<class Sig> struct result; template<class This,class Func,class A0 , class A1 , class A2> struct result<This(Func, A0 , A1 , A2)> { typedef typename meta:: result_of< typename meta:: strip<Func>::type const( typename meta::scalar_of<A0>::type , typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> type; }; template<class A0 , class A1 , class A2 , class A3> inline typename meta::result_of<call(A0 const& , A1 const& , A2 const& , A3 const&)>::type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 ) const { typedef typename result<call(A0 , A1 , A2 , A3)>::type ntype; typedef typename result<call(A0 , A1 , A2 , A3)>::stype stype; return make<ntype>(details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0] , a3[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1] , a3[ 1])) , details::maybe_genmask<stype>(a0(a1[ 2] , a2[ 2] , a3[ 2])) , details::maybe_genmask<stype>(a0(a1[ 3] , a2[ 3] , a3[ 3]))); } }; } } namespace nt2 { namespace meta { template<class Func , class A0 , class A1 , class A2 , class A3> nt2::ext:: call< tag::map_(typename nt2::meta::unspecified_<Func>::type , typename nt2::meta::simd_<ints32_<A0>,tag::sse_>::type , typename nt2::meta::simd_< arithmetic_<A1>,tag::sse_>::type , typename nt2::meta::simd_< arithmetic_<A2>,tag::sse_>::type , typename nt2::meta::simd_< arithmetic_<A3>,tag::sse_>::type) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<Func> const& , nt2::meta::simd_<ints32_<A0>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A1>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> const& , adl_helper = adl_helper() ); } } namespace nt2 { namespace ext { template<class Dummy> struct call < tag::map_ ( tag::unspecified_ , tag::simd_< tag::ints32_ , tag::sse_ > ,tag::simd_<tag::arithmetic_,tag::sse_> ,tag::simd_<tag::arithmetic_,tag::sse_> ,tag::simd_<tag::arithmetic_,tag::sse_> ) , tag::cpu_ , Dummy> : callable { template<class Sig> struct result; template<class This,class Func,class A0 , class A1 , class A2 , class A3> struct result<This(Func, A0 , A1 , A2 , A3)> { typedef typename meta:: result_of< typename meta:: strip<Func>::type const( typename meta::scalar_of<A0>::type , typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type , typename meta::scalar_of<A3>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> type; }; template<class A0 , class A1 , class A2 , class A3 , class A4> inline typename meta::result_of<call(A0 const& , A1 const& , A2 const& , A3 const& , A4 const&)>::type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 ) const { typedef typename result<call(A0 , A1 , A2 , A3 , A4)>::type ntype; typedef typename result<call(A0 , A1 , A2 , A3 , A4)>::stype stype; return make<ntype>(details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0] , a3[ 0] , a4[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1] , a3[ 1] , a4[ 1])) , details::maybe_genmask<stype>(a0(a1[ 2] , a2[ 2] , a3[ 2] , a4[ 2])) , details::maybe_genmask<stype>(a0(a1[ 3] , a2[ 3] , a3[ 3] , a4[ 3]))); } }; } }
namespace nt2 { namespace meta { template<class Func , class A0> nt2::ext:: call< tag::map_(typename nt2::meta::unspecified_<Func>::type , typename nt2::meta::simd_<ints16_<A0>,tag::sse_>::type) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<Func> const& , nt2::meta::simd_<ints16_<A0>,tag::sse_> const& , adl_helper = adl_helper() ); } } namespace nt2 { namespace ext { template<class Dummy> struct call < tag::map_ ( tag::unspecified_ , tag::simd_< tag::ints16_ , tag::sse_ > ) , tag::cpu_ , Dummy> : callable { template<class Sig> struct result; template<class This,class Func,class A0> struct result<This(Func, A0)> { typedef typename meta:: result_of< typename meta:: strip<Func>::type const( typename meta::scalar_of<A0>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> type; }; template<class A0 , class A1> inline typename meta::result_of<call(A0 const& , A1 const&)>::type operator()( A0 const& a0 , A1 const& a1 ) const { typedef typename result<call(A0 , A1)>::type ntype; typedef typename result<call(A0 , A1)>::stype stype; return make<ntype>(details::maybe_genmask<stype>(a0(a1[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1])) , details::maybe_genmask<stype>(a0(a1[ 2])) , details::maybe_genmask<stype>(a0(a1[ 3])) , details::maybe_genmask<stype>(a0(a1[ 4])) , details::maybe_genmask<stype>(a0(a1[ 5])) , details::maybe_genmask<stype>(a0(a1[ 6])) , details::maybe_genmask<stype>(a0(a1[ 7]))); } }; } } namespace nt2 { namespace meta { template<class Func , class A0 , class A1> nt2::ext:: call< tag::map_(typename nt2::meta::unspecified_<Func>::type , typename nt2::meta::simd_<ints16_<A0>,tag::sse_>::type , typename nt2::meta::simd_< arithmetic_<A1>,tag::sse_>::type) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<Func> const& , nt2::meta::simd_<ints16_<A0>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A1>,tag::sse_> const& , adl_helper = adl_helper() ); } } namespace nt2 { namespace ext { template<class Dummy> struct call < tag::map_ ( tag::unspecified_ , tag::simd_< tag::ints16_ , tag::sse_ > ,tag::simd_<tag::arithmetic_,tag::sse_> ) , tag::cpu_ , Dummy> : callable { template<class Sig> struct result; template<class This,class Func,class A0 , class A1> struct result<This(Func, A0 , A1)> { typedef typename meta:: result_of< typename meta:: strip<Func>::type const( typename meta::scalar_of<A0>::type , typename meta::scalar_of<A1>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> type; }; template<class A0 , class A1 , class A2> inline typename meta::result_of<call(A0 const& , A1 const& , A2 const&)>::type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 ) const { typedef typename result<call(A0 , A1 , A2)>::type ntype; typedef typename result<call(A0 , A1 , A2)>::stype stype; return make<ntype>(details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1])) , details::maybe_genmask<stype>(a0(a1[ 2] , a2[ 2])) , details::maybe_genmask<stype>(a0(a1[ 3] , a2[ 3])) , details::maybe_genmask<stype>(a0(a1[ 4] , a2[ 4])) , details::maybe_genmask<stype>(a0(a1[ 5] , a2[ 5])) , details::maybe_genmask<stype>(a0(a1[ 6] , a2[ 6])) , details::maybe_genmask<stype>(a0(a1[ 7] , a2[ 7]))); } }; } } namespace nt2 { namespace meta { template<class Func , class A0 , class A1 , class A2> nt2::ext:: call< tag::map_(typename nt2::meta::unspecified_<Func>::type , typename nt2::meta::simd_<ints16_<A0>,tag::sse_>::type , typename nt2::meta::simd_< arithmetic_<A1>,tag::sse_>::type , typename nt2::meta::simd_< arithmetic_<A2>,tag::sse_>::type) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<Func> const& , nt2::meta::simd_<ints16_<A0>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A1>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> const& , adl_helper = adl_helper() ); } } namespace nt2 { namespace ext { template<class Dummy> struct call < tag::map_ ( tag::unspecified_ , tag::simd_< tag::ints16_ , tag::sse_ > ,tag::simd_<tag::arithmetic_,tag::sse_> ,tag::simd_<tag::arithmetic_,tag::sse_> ) , tag::cpu_ , Dummy> : callable { template<class Sig> struct result; template<class This,class Func,class A0 , class A1 , class A2> struct result<This(Func, A0 , A1 , A2)> { typedef typename meta:: result_of< typename meta:: strip<Func>::type const( typename meta::scalar_of<A0>::type , typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> type; }; template<class A0 , class A1 , class A2 , class A3> inline typename meta::result_of<call(A0 const& , A1 const& , A2 const& , A3 const&)>::type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 ) const { typedef typename result<call(A0 , A1 , A2 , A3)>::type ntype; typedef typename result<call(A0 , A1 , A2 , A3)>::stype stype; return make<ntype>(details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0] , a3[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1] , a3[ 1])) , details::maybe_genmask<stype>(a0(a1[ 2] , a2[ 2] , a3[ 2])) , details::maybe_genmask<stype>(a0(a1[ 3] , a2[ 3] , a3[ 3])) , details::maybe_genmask<stype>(a0(a1[ 4] , a2[ 4] , a3[ 4])) , details::maybe_genmask<stype>(a0(a1[ 5] , a2[ 5] , a3[ 5])) , details::maybe_genmask<stype>(a0(a1[ 6] , a2[ 6] , a3[ 6])) , details::maybe_genmask<stype>(a0(a1[ 7] , a2[ 7] , a3[ 7]))); } }; } } namespace nt2 { namespace meta { template<class Func , class A0 , class A1 , class A2 , class A3> nt2::ext:: call< tag::map_(typename nt2::meta::unspecified_<Func>::type , typename nt2::meta::simd_<ints16_<A0>,tag::sse_>::type , typename nt2::meta::simd_< arithmetic_<A1>,tag::sse_>::type , typename nt2::meta::simd_< arithmetic_<A2>,tag::sse_>::type , typename nt2::meta::simd_< arithmetic_<A3>,tag::sse_>::type) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<Func> const& , nt2::meta::simd_<ints16_<A0>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A1>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> const& , adl_helper = adl_helper() ); } } namespace nt2 { namespace ext { template<class Dummy> struct call < tag::map_ ( tag::unspecified_ , tag::simd_< tag::ints16_ , tag::sse_ > ,tag::simd_<tag::arithmetic_,tag::sse_> ,tag::simd_<tag::arithmetic_,tag::sse_> ,tag::simd_<tag::arithmetic_,tag::sse_> ) , tag::cpu_ , Dummy> : callable { template<class Sig> struct result; template<class This,class Func,class A0 , class A1 , class A2 , class A3> struct result<This(Func, A0 , A1 , A2 , A3)> { typedef typename meta:: result_of< typename meta:: strip<Func>::type const( typename meta::scalar_of<A0>::type , typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type , typename meta::scalar_of<A3>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> type; }; template<class A0 , class A1 , class A2 , class A3 , class A4> inline typename meta::result_of<call(A0 const& , A1 const& , A2 const& , A3 const& , A4 const&)>::type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 ) const { typedef typename result<call(A0 , A1 , A2 , A3 , A4)>::type ntype; typedef typename result<call(A0 , A1 , A2 , A3 , A4)>::stype stype; return make<ntype>(details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0] , a3[ 0] , a4[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1] , a3[ 1] , a4[ 1])) , details::maybe_genmask<stype>(a0(a1[ 2] , a2[ 2] , a3[ 2] , a4[ 2])) , details::maybe_genmask<stype>(a0(a1[ 3] , a2[ 3] , a3[ 3] , a4[ 3])) , details::maybe_genmask<stype>(a0(a1[ 4] , a2[ 4] , a3[ 4] , a4[ 4])) , details::maybe_genmask<stype>(a0(a1[ 5] , a2[ 5] , a3[ 5] , a4[ 5])) , details::maybe_genmask<stype>(a0(a1[ 6] , a2[ 6] , a3[ 6] , a4[ 6])) , details::maybe_genmask<stype>(a0(a1[ 7] , a2[ 7] , a3[ 7] , a4[ 7]))); } }; } }
namespace nt2 { namespace meta { template<class Func , class A0> nt2::ext:: call< tag::map_(typename nt2::meta::unspecified_<Func>::type , typename nt2::meta::simd_<ints8_<A0>,tag::sse_>::type) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<Func> const& , nt2::meta::simd_<ints8_<A0>,tag::sse_> const& , adl_helper = adl_helper() ); } } namespace nt2 { namespace ext { template<class Dummy> struct call < tag::map_ ( tag::unspecified_ , tag::simd_< tag::ints8_ , tag::sse_ > ) , tag::cpu_ , Dummy> : callable { template<class Sig> struct result; template<class This,class Func,class A0> struct result<This(Func, A0)> { typedef typename meta:: result_of< typename meta:: strip<Func>::type const( typename meta::scalar_of<A0>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> type; }; template<class A0 , class A1> inline typename meta::result_of<call(A0 const& , A1 const&)>::type operator()( A0 const& a0 , A1 const& a1 ) const { typedef typename result<call(A0 , A1)>::type ntype; typedef typename result<call(A0 , A1)>::stype stype; return make<ntype>(details::maybe_genmask<stype>(a0(a1[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1])) , details::maybe_genmask<stype>(a0(a1[ 2])) , details::maybe_genmask<stype>(a0(a1[ 3])) , details::maybe_genmask<stype>(a0(a1[ 4])) , details::maybe_genmask<stype>(a0(a1[ 5])) , details::maybe_genmask<stype>(a0(a1[ 6])) , details::maybe_genmask<stype>(a0(a1[ 7])) , details::maybe_genmask<stype>(a0(a1[ 8])) , details::maybe_genmask<stype>(a0(a1[ 9])) , details::maybe_genmask<stype>(a0(a1[ 10])) , details::maybe_genmask<stype>(a0(a1[ 11])) , details::maybe_genmask<stype>(a0(a1[ 12])) , details::maybe_genmask<stype>(a0(a1[ 13])) , details::maybe_genmask<stype>(a0(a1[ 14])) , details::maybe_genmask<stype>(a0(a1[ 15]))); } }; } } namespace nt2 { namespace meta { template<class Func , class A0 , class A1> nt2::ext:: call< tag::map_(typename nt2::meta::unspecified_<Func>::type , typename nt2::meta::simd_<ints8_<A0>,tag::sse_>::type , typename nt2::meta::simd_< arithmetic_<A1>,tag::sse_>::type) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<Func> const& , nt2::meta::simd_<ints8_<A0>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A1>,tag::sse_> const& , adl_helper = adl_helper() ); } } namespace nt2 { namespace ext { template<class Dummy> struct call < tag::map_ ( tag::unspecified_ , tag::simd_< tag::ints8_ , tag::sse_ > ,tag::simd_<tag::arithmetic_,tag::sse_> ) , tag::cpu_ , Dummy> : callable { template<class Sig> struct result; template<class This,class Func,class A0 , class A1> struct result<This(Func, A0 , A1)> { typedef typename meta:: result_of< typename meta:: strip<Func>::type const( typename meta::scalar_of<A0>::type , typename meta::scalar_of<A1>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> type; }; template<class A0 , class A1 , class A2> inline typename meta::result_of<call(A0 const& , A1 const& , A2 const&)>::type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 ) const { typedef typename result<call(A0 , A1 , A2)>::type ntype; typedef typename result<call(A0 , A1 , A2)>::stype stype; return make<ntype>(details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1])) , details::maybe_genmask<stype>(a0(a1[ 2] , a2[ 2])) , details::maybe_genmask<stype>(a0(a1[ 3] , a2[ 3])) , details::maybe_genmask<stype>(a0(a1[ 4] , a2[ 4])) , details::maybe_genmask<stype>(a0(a1[ 5] , a2[ 5])) , details::maybe_genmask<stype>(a0(a1[ 6] , a2[ 6])) , details::maybe_genmask<stype>(a0(a1[ 7] , a2[ 7])) , details::maybe_genmask<stype>(a0(a1[ 8] , a2[ 8])) , details::maybe_genmask<stype>(a0(a1[ 9] , a2[ 9])) , details::maybe_genmask<stype>(a0(a1[ 10] , a2[ 10])) , details::maybe_genmask<stype>(a0(a1[ 11] , a2[ 11])) , details::maybe_genmask<stype>(a0(a1[ 12] , a2[ 12])) , details::maybe_genmask<stype>(a0(a1[ 13] , a2[ 13])) , details::maybe_genmask<stype>(a0(a1[ 14] , a2[ 14])) , details::maybe_genmask<stype>(a0(a1[ 15] , a2[ 15]))); } }; } } namespace nt2 { namespace meta { template<class Func , class A0 , class A1 , class A2> nt2::ext:: call< tag::map_(typename nt2::meta::unspecified_<Func>::type , typename nt2::meta::simd_<ints8_<A0>,tag::sse_>::type , typename nt2::meta::simd_< arithmetic_<A1>,tag::sse_>::type , typename nt2::meta::simd_< arithmetic_<A2>,tag::sse_>::type) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<Func> const& , nt2::meta::simd_<ints8_<A0>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A1>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> const& , adl_helper = adl_helper() ); } } namespace nt2 { namespace ext { template<class Dummy> struct call < tag::map_ ( tag::unspecified_ , tag::simd_< tag::ints8_ , tag::sse_ > ,tag::simd_<tag::arithmetic_,tag::sse_> ,tag::simd_<tag::arithmetic_,tag::sse_> ) , tag::cpu_ , Dummy> : callable { template<class Sig> struct result; template<class This,class Func,class A0 , class A1 , class A2> struct result<This(Func, A0 , A1 , A2)> { typedef typename meta:: result_of< typename meta:: strip<Func>::type const( typename meta::scalar_of<A0>::type , typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> type; }; template<class A0 , class A1 , class A2 , class A3> inline typename meta::result_of<call(A0 const& , A1 const& , A2 const& , A3 const&)>::type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 ) const { typedef typename result<call(A0 , A1 , A2 , A3)>::type ntype; typedef typename result<call(A0 , A1 , A2 , A3)>::stype stype; return make<ntype>(details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0] , a3[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1] , a3[ 1])) , details::maybe_genmask<stype>(a0(a1[ 2] , a2[ 2] , a3[ 2])) , details::maybe_genmask<stype>(a0(a1[ 3] , a2[ 3] , a3[ 3])) , details::maybe_genmask<stype>(a0(a1[ 4] , a2[ 4] , a3[ 4])) , details::maybe_genmask<stype>(a0(a1[ 5] , a2[ 5] , a3[ 5])) , details::maybe_genmask<stype>(a0(a1[ 6] , a2[ 6] , a3[ 6])) , details::maybe_genmask<stype>(a0(a1[ 7] , a2[ 7] , a3[ 7])) , details::maybe_genmask<stype>(a0(a1[ 8] , a2[ 8] , a3[ 8])) , details::maybe_genmask<stype>(a0(a1[ 9] , a2[ 9] , a3[ 9])) , details::maybe_genmask<stype>(a0(a1[ 10] , a2[ 10] , a3[ 10])) , details::maybe_genmask<stype>(a0(a1[ 11] , a2[ 11] , a3[ 11])) , details::maybe_genmask<stype>(a0(a1[ 12] , a2[ 12] , a3[ 12])) , details::maybe_genmask<stype>(a0(a1[ 13] , a2[ 13] , a3[ 13])) , details::maybe_genmask<stype>(a0(a1[ 14] , a2[ 14] , a3[ 14])) , details::maybe_genmask<stype>(a0(a1[ 15] , a2[ 15] , a3[ 15]))); } }; } } namespace nt2 { namespace meta { template<class Func , class A0 , class A1 , class A2 , class A3> nt2::ext:: call< tag::map_(typename nt2::meta::unspecified_<Func>::type , typename nt2::meta::simd_<ints8_<A0>,tag::sse_>::type , typename nt2::meta::simd_< arithmetic_<A1>,tag::sse_>::type , typename nt2::meta::simd_< arithmetic_<A2>,tag::sse_>::type , typename nt2::meta::simd_< arithmetic_<A3>,tag::sse_>::type) , tag::cpu_ > dispatching( tag::map_ const&, tag::cpu_ const& , nt2::meta::unspecified_<Func> const& , nt2::meta::simd_<ints8_<A0>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A1>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A2>,tag::sse_> const& , nt2::meta::simd_< arithmetic_<A3>,tag::sse_> const& , adl_helper = adl_helper() ); } } namespace nt2 { namespace ext { template<class Dummy> struct call < tag::map_ ( tag::unspecified_ , tag::simd_< tag::ints8_ , tag::sse_ > ,tag::simd_<tag::arithmetic_,tag::sse_> ,tag::simd_<tag::arithmetic_,tag::sse_> ,tag::simd_<tag::arithmetic_,tag::sse_> ) , tag::cpu_ , Dummy> : callable { template<class Sig> struct result; template<class This,class Func,class A0 , class A1 , class A2 , class A3> struct result<This(Func, A0 , A1 , A2 , A3)> { typedef typename meta:: result_of< typename meta:: strip<Func>::type const( typename meta::scalar_of<A0>::type , typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type , typename meta::scalar_of<A3>::type ) >::type rtype; typedef typename details:: as_native< Func , rtype , typename meta::scalar_of<A0>::type >::type stype; typedef simd::native<stype, tag::sse_> type; }; template<class A0 , class A1 , class A2 , class A3 , class A4> inline typename meta::result_of<call(A0 const& , A1 const& , A2 const& , A3 const& , A4 const&)>::type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 ) const { typedef typename result<call(A0 , A1 , A2 , A3 , A4)>::type ntype; typedef typename result<call(A0 , A1 , A2 , A3 , A4)>::stype stype; return make<ntype>(details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0] , a3[ 0] , a4[ 0])) , details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1] , a3[ 1] , a4[ 1])) , details::maybe_genmask<stype>(a0(a1[ 2] , a2[ 2] , a3[ 2] , a4[ 2])) , details::maybe_genmask<stype>(a0(a1[ 3] , a2[ 3] , a3[ 3] , a4[ 3])) , details::maybe_genmask<stype>(a0(a1[ 4] , a2[ 4] , a3[ 4] , a4[ 4])) , details::maybe_genmask<stype>(a0(a1[ 5] , a2[ 5] , a3[ 5] , a4[ 5])) , details::maybe_genmask<stype>(a0(a1[ 6] , a2[ 6] , a3[ 6] , a4[ 6])) , details::maybe_genmask<stype>(a0(a1[ 7] , a2[ 7] , a3[ 7] , a4[ 7])) , details::maybe_genmask<stype>(a0(a1[ 8] , a2[ 8] , a3[ 8] , a4[ 8])) , details::maybe_genmask<stype>(a0(a1[ 9] , a2[ 9] , a3[ 9] , a4[ 9])) , details::maybe_genmask<stype>(a0(a1[ 10] , a2[ 10] , a3[ 10] , a4[ 10])) , details::maybe_genmask<stype>(a0(a1[ 11] , a2[ 11] , a3[ 11] , a4[ 11])) , details::maybe_genmask<stype>(a0(a1[ 12] , a2[ 12] , a3[ 12] , a4[ 12])) , details::maybe_genmask<stype>(a0(a1[ 13] , a2[ 13] , a3[ 13] , a4[ 13])) , details::maybe_genmask<stype>(a0(a1[ 14] , a2[ 14] , a3[ 14] , a4[ 14])) , details::maybe_genmask<stype>(a0(a1[ 15] , a2[ 15] , a3[ 15] , a4[ 15]))); } }; } }
